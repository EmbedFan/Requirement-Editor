"""
Markdown Requirements Document to Interactive HTML Converter

This module provides the main entry point for converting markdown-formatted requirement 
documents into interactive, styled HTML documents with hierarchical organization and 
modern web features.

Key Features:
- Orchestrates the complete workflow from markdown parsing to HTML generation
- Provides detailed console output for verification and debugging
- Handles file I/O operations with proper error handling
- Configurable input file path for easy adaptation

Workflow:
1. Read markdown file using parsing module
2. Parse and classify document elements 
3. Display detailed classification results to console
4. Generate interactive HTML document with styling and JavaScript
5. Save HTML to output file

Output Features:
- Color-coded element types (green=requirements, yellow=comments, blue=subtitles)
- Interactive expand/collapse for all elements except titles
- Line number references for traceability
- Print-optimized styling with background color preservation
- Control buttons (hidden during printing): Expand All, Collapse All, Toggle Line Numbers, Print to PDF

Usage:
    python main.py

Configuration:
    cfg_inputfile: Path to input markdown file (modify at top of file)
    
Dependencies:
    - libs.parse_req_md: Markdown parsing functionality
    - libs.gen_html_doc: HTML generation functionality
    
Author: Attila Gallai <attila@tux-net.hu>
Created: 2025
License: MIT License (see LICENSE.txt)
"""

from libs.parse_req_md import ReadMDFile, ClassifyParts
from libs.gen_html_doc import GenerateHTML

cfg_inputfile = "C:\\Munka\\Sandbox\\PromptEnginering\\Requirement Editor\\python\\testfiles\\test_input.md"


def SaveHTMLFile(html_content, filename):
    """
    Save HTML content to a file with proper encoding and error handling.
    
    Writes the provided HTML content to a file using UTF-8 encoding to ensure
    proper handling of international characters and special symbols that may
    be present in requirement documents.
    
    Args:
        html_content (str): Complete HTML document content to save. Should be
                           a valid HTML string, typically generated by GenerateHTML().
        filename (str): Output filename with path. Can be absolute or relative path.
                       Recommended to use .html extension for proper file association.
        
    Returns:
        bool: True if file was saved successfully, False if an error occurred.
              Error details are printed to console but function doesn't raise exceptions.
              
    Error Handling:
        - Catches and handles IOError exceptions (file permissions, disk space, etc.)
        - Prints descriptive error messages to console
        - Returns False on any error to allow calling code to handle gracefully
        
    Note:
        - Uses UTF-8 encoding which supports international characters
        - Creates parent directories if they don't exist (depends on OS)
        - Overwrites existing files without warning
        - File is automatically closed even if write operation fails
    """
    try:
        with open(filename, 'w', encoding='utf-8') as file:
            file.write(html_content)
        return True
    except IOError as e:
        print(f"Error saving HTML file '{filename}': {e}")
        return False


def main():
    """
    Main entry point for the Markdown to HTML requirement document converter.
    
    Orchestrates the complete workflow of reading a markdown requirements document,
    parsing and classifying its contents, generating an interactive HTML document,
    and saving the result to a file. This function serves as the workflow coordinator,
    delegating specialized tasks to appropriate modules.
    
    Workflow:
    1. **File Reading**: Uses ReadMDFile() from libs.parse_req_md to read input markdown
    2. **Content Parsing**: Uses ClassifyParts() from libs.parse_req_md to parse and classify elements
    3. **Console Display**: Shows detailed classification results for verification and debugging
    4. **HTML Generation**: Uses GenerateHTML() from libs.gen_html_doc to create interactive HTML
    5. **File Output**: Uses local SaveHTMLFile() to save the result with proper encoding
    
    Console Output Features:
    - File reading success/failure messages with character counts
    - Detailed classification table showing:
      * Line numbers and element types (TITLE, SUBTITLE, REQUIREMENT, COMMENT, UNKNOWN)
      * Indentation levels and ID numbers for requirements/comments
      * Parent-child relationships in the document hierarchy
      * Description text (truncated to 120 characters for readability)
    - HTML generation and file saving status messages
    
    Error Handling Strategy:
    - Gracefully handles file reading errors from the parsing module
    - Continues processing even if some steps fail (except critical file reading)
    - Provides informative error messages to user at each step
    - Exits gracefully with clear message if input file cannot be read
    
    Configuration:
    - Input file path specified in global variable cfg_inputfile
    - Output file automatically determined by replacing .md extension with .html
    - HTML document title set to "Requirement Document for Requirement Editor"
    
    Module Dependencies:
    - libs.parse_req_md.ReadMDFile(): File input with UTF-8 encoding and error handling
    - libs.parse_req_md.ClassifyParts(): Content parsing, classification, and hierarchy building
    - libs.gen_html_doc.GenerateHTML(): Interactive HTML generation with CSS and JavaScript
    - Local SaveHTMLFile(): File output with UTF-8 encoding and error handling
    
    Integration Notes:
    - Serves as the primary orchestrator in a modular architecture
    - Minimal business logic - delegates specialized tasks to appropriate modules
    - Provides user feedback and transparency throughout the conversion process
    - No return value - results are saved to file and status printed to console
    
    Example Console Output:
    ```
    Successfully read 1247 characters from C:\...\test_input.md
    
    Classified 15 parts:
    ----------------------------------------------------------------------------------------------------
    Line  1: Type: TITLE        | Indent: 0 | ID:  N/A | Parent: None | Children: [2, 5]
             Description: System Requirements...
    
    Line  2: Type: SUBTITLE     | Indent: 1 | ID:  N/A | Parent: 1 | Children: [3, 4]  
             Description: User Interface...
    
    HTML file saved successfully: C:\...\test_input.html
    ```
    """

    # Read the markdown file
    md_content = ReadMDFile(cfg_inputfile)
    
    if md_content:
        print(f"Successfully read {len(md_content)} characters from {cfg_inputfile}")
        
        # Classify the parts
        classified_parts = ClassifyParts(md_content)
        
        print(f"\nClassified {len(classified_parts)} parts:")
        print("-" * 100)
        
        for part in classified_parts:
            parent_info = f"Parent: {part['parent']}" if part['parent'] else "Parent: None"
            children_info = f"Children: {part['children']}" if part['children'] else "Children: None"
            
            print(f"Line {part['line_number']:2d}: "
                  f"Type: {part['type']:12s} | "
                  f"Indent: {part['indent']} | "
                  f"ID: {str(part['id']) if part['id'] else 'N/A':>4s} | "
                  f"{parent_info} | "
                  f"{children_info}")
            print(f"         Description: {part['description'][:120]}...")
            print()
        
        # Generate HTML
        html_content = GenerateHTML(classified_parts, "Requirement Document for Requirement Editor")
        
        # Save HTML file
        html_filename = cfg_inputfile.replace('.md', '.html')
        if SaveHTMLFile(html_content, html_filename):
            print(f"\nHTML file saved successfully: {html_filename}")
        else:
            print("\nFailed to save HTML file")
        
    else:
        print("Failed to read the markdown file. Exiting...")

    pass


if __name__ == "__main__":
    main()
"""
In-Memory Markdown File Editor Module for Requirement Documents

This module provides comprehensive editing functionality for manipulating structured
requirement document elements in memory. It operates on the classified parts structure
generated by the parse_req_md module, allowing for sophisticated document editing
operations while maintaining hierarchical relationships and proper formatting.

Core Architecture:
The editor operates directly on the classified parts data structure, providing
high-level editing operations that automatically handle:
- Hierarchical parent-child relationships
- Line number-based positioning and referencing
- Indentation level adjustments
- Item ID sequence management (for requirements/comments/dattr)
- Content validation and formatting

Line Number System:
The editor uses line numbers for positioning and referencing elements within the document.
Line numbers are automatically updated after insertions, deletions, and movements to
maintain sequential numbering. All operations work with current line numbers:
- **Line Numbers**: Sequential position identifiers (1-based, auto-updated)
- **Item IDs**: Semantic IDs for requirements/comments/dattr (user-controllable)

Editing Operations Supported:
- **Positional Operations**: Insert items before, after, or under existing elements using line numbers
- **Movement Operations**: Move items to different positions with automatic re-parenting
- **Content Operations**: Get, update, and delete element content
- **Type Operations**: Change element types with proper validation
- **Structural Operations**: Maintain document hierarchy and relationships

Data Structure Integration:
The module works seamlessly with the classified parts structure:
```python
{
    'line_number': int,        # Sequential line number (1-based, auto-updated)
    'original_line': str,      # Complete unmodified line text
    'type': str,              # 'TITLE', 'SUBTITLE', 'REQUIREMENT', 'COMMENT', 'DATTR', 'UNKNOWN'
    'indent': int,            # Indentation level (0-10)
    'id': int|None,           # Element ID number if applicable (requirements/comments/dattr)
    'description': str,       # Element description text
    'parent': int|None,       # Parent element line number
    'children': list,         # List of child element line numbers
    'children_refs': list     # List of direct references to child elements
}
```

Automatic Management Features:
- **Line Number Renumbering**: Automatically updates line numbers after insertions/deletions
- **Parent-Child Relationship Maintenance**: Keeps hierarchical structure consistent
- **Indentation Management**: Automatically adjusts indentation based on hierarchy
- **Item ID Sequence Management**: Handles requirement/comment/dattr ID assignment and uniqueness
- **Content Validation**: Ensures proper formatting for each element type

Error Handling Strategy:
- Comprehensive validation of input parameters and line number references
- Graceful handling of invalid operations with informative error messages
- Atomic operations that maintain document consistency even on partial failures
- Rollback capabilities for complex multi-step operations

Performance Considerations:
- Efficient algorithms for large document manipulation
- Optimized line number updates and parent-child relationship management
- Minimal memory overhead with in-place operations where possible

Integration with Workflow:
- Compatible with existing parse_req_md.ClassifyParts() output
- Integrates with gen_html_doc.GenerateHTML() for immediate visualization
- Supports round-trip editing (parse → edit → regenerate)
- Maintains full compatibility with existing file I/O operations

Example Usage:
```python
# Load and parse document
md_content = ReadMDFile("requirements.md")
classified_parts = ClassifyParts(md_content)

# Create editor instance
editor = MarkdownEditor(classified_parts)

# Find line number for a specific requirement
line_num = editor.find_by_item_id(1005, 'REQUIREMENT')

# Add new requirement after existing one using line number
new_req = editor.add_item_after(target_line=line_num, 
                               item_type='REQUIREMENT',
                               description='New requirement description',
                               item_id=1050)

# Move item to different location using line numbers
editor.move_item_under(source_line=new_req['line_number'], target_line=line_num)

# Update content using line number
editor.update_content(line_number=line_num, new_description='Updated description')

# Get modified structure
modified_parts = editor.get_classified_parts()
```

Author: Attila Gallai <attila@tux-net.hu>
Created: 2025-07-10
Version: 1.0.0 - Line number-based editing system
License: MIT License (see LICENSE.txt)
"""

import copy
from typing import List, Dict, Optional, Union, Any


class MarkdownEditor:
    """
    In-memory markdown document editor for requirement documents.
    
    Provides comprehensive editing operations for manipulating structured requirement
    document elements while maintaining hierarchical relationships and proper formatting.
    Uses line numbers for positioning and referencing elements.
    """

    def __init__(self, classified_parts: List[Dict[str, Any]]):
        """
        Initialize the markdown editor with classified parts.
        
        Args:
            classified_parts (List[Dict]): List of classified parts from parse_req_md.ClassifyParts()
        """
        self.classified_parts = copy.deepcopy(classified_parts)
        self._validate_structure()
    
    def _validate_structure(self):
        """Validate the classified parts structure for consistency."""
        if not isinstance(self.classified_parts, list):
            raise ValueError("classified_parts must be a list")
        
        for part in self.classified_parts:
            required_keys = ['line_number', 'type', 'indent', 'description', 'parent', 'children', 'children_refs']
            for key in required_keys:
                if key not in part:
                    raise ValueError(f"Missing required key '{key}' in classified part")
    
    def _renumber_lines(self):
        """Renumber all line numbers sequentially starting from 1."""
        old_to_new_mapping = {}
        
        # Create mapping of old line numbers to new line numbers
        for i, part in enumerate(self.classified_parts):
            old_line = part['line_number']
            new_line = i + 1
            old_to_new_mapping[old_line] = new_line
            part['line_number'] = new_line
        
        # Update parent references
        for part in self.classified_parts:
            if part['parent'] is not None:
                part['parent'] = old_to_new_mapping.get(part['parent'])
        
        # Update children references
        for part in self.classified_parts:
            part['children'] = [old_to_new_mapping.get(child) for child in part['children'] if child in old_to_new_mapping]
        
        # Rebuild children_refs
        self._rebuild_children_refs()
    
    def _rebuild_children_refs(self):
        """Rebuild children_refs based on current parent-child relationships."""
        # Clear all children_refs
        for part in self.classified_parts:
            part['children_refs'] = []
        
        # Build mapping of line_number to part reference
        line_to_part = {part['line_number']: part for part in self.classified_parts}
        
        # Rebuild children_refs
        for part in self.classified_parts:
            for child_line in part['children']:
                if child_line in line_to_part:
                    part['children_refs'].append(line_to_part[child_line])
    
    def _find_part_by_line(self, line_number: int) -> Optional[Dict[str, Any]]:
        """Find a part by its line number."""
        for part in self.classified_parts:
            if part['line_number'] == line_number:
                return part
        return None
    
    def _get_next_item_id(self, id_type: str) -> int:
        """Get the next available ID for requirements, comments, or dattr."""
        max_id = 0
        for part in self.classified_parts:
            if part.get('id') and part['type'] in ['REQUIREMENT', 'COMMENT', 'DATTR']:
                max_id = max(max_id, part['id'])
        return max_id + 1
    
    def _create_new_part(self, item_type: str, description: str, indent: int = 0, 
                        item_id: Optional[int] = None) -> Dict[str, Any]:
        """Create a new part with proper structure."""
        # Auto-assign item ID for types that need it
        if item_type in ['REQUIREMENT', 'COMMENT', 'DATTR'] and item_id is None:
            item_id = self._get_next_item_id(item_type)
        
        new_part = {
            'line_number': len(self.classified_parts) + 1,  # Temporary, will be renumbered
            'original_line': '',  # Will be generated when saving
            'type': item_type,
            'indent': indent,
            'id': item_id,
            'description': description,
            'parent': None,
            'children': [],
            'children_refs': []
        }
        
        return new_part
    
    def _update_parent_child_relationships(self):
        """Update all parent-child relationships based on indentation and position."""
        # Clear existing relationships
        for part in self.classified_parts:
            part['parent'] = None
            part['children'] = []
        
        # Rebuild relationships using similar logic to parse_req_md._build_hierarchy
        parent_stack = []
        
        for part in self.classified_parts:
            current_indent = part['indent']
            
            # Remove parents from stack that are at same or deeper level
            while parent_stack and parent_stack[-1]['indent'] >= current_indent:
                parent_stack.pop()
            
            # Set parent if stack is not empty
            if parent_stack:
                parent = parent_stack[-1]
                part['parent'] = parent['line_number']
                parent['children'].append(part['line_number'])
            
            # Add current part to stack for potential children
            parent_stack.append(part)
        
        # Rebuild children_refs
        self._rebuild_children_refs()

    # Search and utility methods
    
    def find_by_item_id(self, item_id: int, item_type: Optional[str] = None) -> Optional[int]:
        """
        Find the line number of an element by its item ID (requirement/comment/dattr ID).
        
        Args:
            item_id (int): The item ID to search for (e.g., 1001, 1002)
            item_type (Optional[str]): Filter by type ('REQUIREMENT', 'COMMENT', 'DATTR')
            
        Returns:
            Optional[int]: Line number of the found element, or None if not found
        """
        for part in self.classified_parts:
            if (part.get('id') == item_id and 
                part['type'] in ['REQUIREMENT', 'COMMENT', 'DATTR'] and
                (item_type is None or part['type'] == item_type)):
                return part['line_number']
        return None
    
    def find_by_description(self, description_pattern: str, case_sensitive: bool = False) -> List[int]:
        """
        Find line numbers of elements containing the specified description pattern.
        
        Args:
            description_pattern (str): Text pattern to search for
            case_sensitive (bool): Whether search should be case sensitive
            
        Returns:
            List[int]: List of line numbers for matching elements
        """
        results = []
        search_pattern = description_pattern if case_sensitive else description_pattern.lower()
        
        for part in self.classified_parts:
            search_text = part['description'] if case_sensitive else part['description'].lower()
            if search_pattern in search_text:
                results.append(part['line_number'])
        
        return results
    
    def get_children(self, line_number: int) -> List[int]:
        """
        Get the line numbers of all direct children of the specified element.
        
        Args:
            line_number (int): Line number of the parent element
            
        Returns:
            List[int]: List of child line numbers
        """
        part = self._find_part_by_line(line_number)
        return part['children'][:] if part else []
    
    def get_parent(self, line_number: int) -> Optional[int]:
        """
        Get the line number of the parent element.
        
        Args:
            line_number (int): Line number of the child element
            
        Returns:
            Optional[int]: Line number of the parent, or None if no parent
        """
        part = self._find_part_by_line(line_number)
        return part['parent'] if part else None

    # Core editing operations
    
    
    def add_item_before(self, target_line: int, item_type: str, description: str, 
                       item_id: Optional[int] = None) -> Dict[str, Any]:
        """
        Add a new item before the specified target item.
        
        Args:
            target_line (int): Line number of the target item
            item_type (str): Type of new item ('TITLE', 'SUBTITLE', 'REQUIREMENT', 'COMMENT', 'DATTR', 'UNKNOWN')
            description (str): Description text for the new item
            item_id (Optional[int]): ID for the new item (auto-assigned if not provided)
            
        Returns:
            Dict: The newly created part
            
        Raises:
            ValueError: If target_line not found or invalid parameters
        """
        target_part = self._find_part_by_line(target_line)
        if not target_part:
            raise ValueError(f"Target line {target_line} not found")
        
        # Find insertion index
        target_index = self.classified_parts.index(target_part)
        
        # Create new part with same indent as target
        new_part = self._create_new_part(item_type, description, target_part['indent'], item_id)
        
        # Insert before target
        self.classified_parts.insert(target_index, new_part)
        
        # Renumber and update relationships
        self._renumber_lines()
        self._update_parent_child_relationships()
        
        return new_part
    
    def add_item_after(self, target_line: int, item_type: str, description: str, 
                      item_id: Optional[int] = None) -> Dict[str, Any]:
        """
        Add a new item after the specified target item.
        
        Args:
            target_line (int): Line number of the target item
            item_type (str): Type of new item
            description (str): Description text for the new item
            item_id (Optional[int]): ID for the new item
            
        Returns:
            Dict: The newly created part
        """
        target_part = self._find_part_by_line(target_line)
        if not target_part:
            raise ValueError(f"Target line {target_line} not found")
        
        # Find insertion index (after target and all its children)
        target_index = self.classified_parts.index(target_part)
        
        # Find where to insert (after target and all its descendants)
        insert_index = target_index + 1
        target_indent = target_part['indent']
        
        # Skip over all children (items with higher indent that follow)
        while (insert_index < len(self.classified_parts) and 
               self.classified_parts[insert_index]['indent'] > target_indent):
            insert_index += 1
        
        # Create new part with same indent as target
        new_part = self._create_new_part(item_type, description, target_part['indent'], item_id)
        
        # Insert after target and its children
        self.classified_parts.insert(insert_index, new_part)
        
        # Renumber and update relationships
        self._renumber_lines()
        self._update_parent_child_relationships()
        
        return new_part
    
    def add_item_under(self, target_line: int, item_type: str, description: str, 
                      item_id: Optional[int] = None) -> Dict[str, Any]:
        """
        Add a new item as a child under the specified target item.
        
        Args:
            target_line (int): Line number of the target parent item
            item_type (str): Type of new item
            description (str): Description text for the new item
            item_id (Optional[int]): ID for the new item
            
        Returns:
            Dict: The newly created part
        """
        target_part = self._find_part_by_line(target_line)
        if not target_part:
            raise ValueError(f"Target line {target_line} not found")
        
        # Find insertion index (after target but before siblings)
        target_index = self.classified_parts.index(target_part)
        insert_index = target_index + 1
        
        # Create new part with indent one level deeper than target
        new_indent = target_part['indent'] + 1
        new_part = self._create_new_part(item_type, description, new_indent, item_id)
        
        # Insert as first child
        self.classified_parts.insert(insert_index, new_part)
        
        # Renumber and update relationships
        self._renumber_lines()
        self._update_parent_child_relationships()
        
        return new_part
    
    def move_item_before(self, source_line: int, target_line: int) -> bool:
        """
        Move an item to before the specified target item.
        
        Args:
            source_line (int): Line number of item to move
            target_line (int): Line number of target item
            
        Returns:
            bool: True if successful
        """
        source_part = self._find_part_by_line(source_line)
        target_part = self._find_part_by_line(target_line)
        
        if not source_part or not target_part:
            raise ValueError("Source or target line not found")
        
        if source_line == target_line:
            return True  # Nothing to do
        
        # Remove source (and its children) from current position
        items_to_move = self._extract_item_and_children(source_line)
        
        # Find target position
        target_part = self._find_part_by_line(target_line)  # Refind after extraction
        if not target_part:
            raise ValueError("Target line not found after extraction")
        
        target_index = self.classified_parts.index(target_part)
        
        # Adjust indent of moved items to match target
        indent_adjustment = target_part['indent'] - items_to_move[0]['indent']
        for item in items_to_move:
            item['indent'] = max(0, item['indent'] + indent_adjustment)
        
        # Insert before target
        for i, item in enumerate(items_to_move):
            self.classified_parts.insert(target_index + i, item)
        
        # Renumber and update relationships
        self._renumber_lines()
        self._update_parent_child_relationships()
        
        return True
    
    def move_item_after(self, source_line: int, target_line: int) -> bool:
        """
        Move an item to after the specified target item.
        
        Args:
            source_line (int): Line number of item to move
            target_line (int): Line number of target item
            
        Returns:
            bool: True if successful
        """
        source_part = self._find_part_by_line(source_line)
        target_part = self._find_part_by_line(target_line)
        
        if not source_part or not target_part:
            raise ValueError("Source or target line not found")
        
        if source_line == target_line:
            return True  # Nothing to do
        
        # Remove source (and its children) from current position
        items_to_move = self._extract_item_and_children(source_line)
        
        # Find target position (after target and its children)
        target_part = self._find_part_by_line(target_line)  # Refind after extraction
        if not target_part:
            raise ValueError("Target line not found after extraction")
        
        target_index = self._find_insert_after_index(target_part['line_number'])
        
        # Adjust indent of moved items to match target
        indent_adjustment = target_part['indent'] - items_to_move[0]['indent']
        for item in items_to_move:
            item['indent'] = max(0, item['indent'] + indent_adjustment)
        
        # Insert after target and its children
        for i, item in enumerate(items_to_move):
            self.classified_parts.insert(target_index + i, item)
        
        # Renumber and update relationships
        self._renumber_lines()
        self._update_parent_child_relationships()
        
        return True
    
    def move_item_under(self, source_line: int, target_line: int) -> bool:
        """
        Move an item to be a child under the specified target item.
        
        Args:
            source_line (int): Line number of item to move
            target_line (int): Line number of target parent item
            
        Returns:
            bool: True if successful
        """
        source_part = self._find_part_by_line(source_line)
        target_part = self._find_part_by_line(target_line)
        
        if not source_part or not target_part:
            raise ValueError("Source or target line not found")
        
        if source_line == target_line:
            return True  # Nothing to do
        
        # Remove source (and its children) from current position
        items_to_move = self._extract_item_and_children(source_line)
        
        # Find target position
        target_part = self._find_part_by_line(target_line)  # Refind after extraction
        if not target_part:
            raise ValueError("Target line not found after extraction")
        
        target_index = self.classified_parts.index(target_part)
        
        # Adjust indent of moved items (one level deeper than target)
        new_base_indent = target_part['indent'] + 1
        indent_adjustment = new_base_indent - items_to_move[0]['indent']
        for item in items_to_move:
            item['indent'] = max(0, item['indent'] + indent_adjustment)
        
        # Insert as children of target
        for i, item in enumerate(items_to_move):
            self.classified_parts.insert(target_index + 1 + i, item)
        
        # Renumber and update relationships
        self._renumber_lines()
        self._update_parent_child_relationships()
        
        return True
    
    
    def _extract_item_and_children(self, line_number: int) -> List[Dict[str, Any]]:
        """Extract an item and all its children from the classified_parts list using line number."""
        source_part = self._find_part_by_line(line_number)
        if not source_part:
            raise ValueError(f"Line number {line_number} not found")
        
        items_to_extract = []
        source_index = self.classified_parts.index(source_part)
        source_indent = source_part['indent']
        
        # Add the source item
        items_to_extract.append(source_part)
        
        # Add all children (items with higher indent that immediately follow)
        i = source_index + 1
        while i < len(self.classified_parts):
            if self.classified_parts[i]['indent'] > source_indent:
                items_to_extract.append(self.classified_parts[i])
                i += 1
            else:
                break
        
        # Remove from original list
        for item in items_to_extract:
            self.classified_parts.remove(item)
        
        return items_to_extract
    
    def _find_insert_after_index(self, line_number: int) -> int:
        """Find the index where items should be inserted after the given line and its children."""
        target_part = self._find_part_by_line(line_number)
        if not target_part:
            raise ValueError(f"Line number {line_number} not found")
        
        target_index = self.classified_parts.index(target_part)
        target_indent = target_part['indent']
        
        # Find the end of target's children
        insert_index = target_index + 1
        while (insert_index < len(self.classified_parts) and 
               self.classified_parts[insert_index]['indent'] > target_indent):
            insert_index += 1
        
        return insert_index
    
    
    def change_item_type(self, line_number: int, new_type: str, new_item_id: Optional[int] = None) -> bool:
        """
        Change the type of an existing item.
        
        Args:
            line_number (int): Line number of item to change
            new_type (str): New type ('TITLE', 'SUBTITLE', 'REQUIREMENT', 'COMMENT', 'DATTR', 'UNKNOWN')
            new_item_id (Optional[int]): New item ID if applicable
            
        Returns:
            bool: True if successful
        """
        part = self._find_part_by_line(line_number)
        if not part:
            raise ValueError(f"Line number {line_number} not found")
        
        # Update type
        part['type'] = new_type
        
        # Handle ID assignment
        if new_type in ['REQUIREMENT', 'COMMENT', 'DATTR']:
            if new_item_id is not None:
                part['id'] = new_item_id
            elif part.get('id') is None:
                part['id'] = self._get_next_item_id(new_type)
        else:
            part['id'] = None
        
        return True
    
    def delete_item(self, line_number: int, delete_children: bool = True) -> bool:
        """
        Delete an item and optionally its children.
        
        Args:
            line_number (int): Line number of item to delete
            delete_children (bool): Whether to delete children as well
            
        Returns:
            bool: True if successful
        """
        part = self._find_part_by_line(line_number)
        if not part:
            raise ValueError(f"Line number {line_number} not found")
        
        if delete_children:
            # Remove item and all its children
            items_to_remove = self._extract_item_and_children(line_number)
        else:
            # Remove only the item, promote children to parent level
            self.classified_parts.remove(part)
            
            # Adjust children's indent to match deleted item's parent level
            children_lines = part.get('children', [])
            for child_line in children_lines:
                child_part = self._find_part_by_line(child_line)
                if child_part:
                    child_part['indent'] = max(0, child_part['indent'] - 1)
        
        # Renumber and update relationships
        self._renumber_lines()
        self._update_parent_child_relationships()
        
        return True
    
    def get_content(self, line_number: int) -> Optional[str]:
        """
        Get the content/description of an item.
        
        Args:
            line_number (int): Line number of item
            
        Returns:
            Optional[str]: Description text or None if not found
        """
        part = self._find_part_by_line(line_number)
        return part['description'] if part else None
    
    def update_content(self, line_number: int, new_description: str) -> bool:
        """
        Update the content/description of an item.
        
        Args:
            line_number (int): Line number of item to update
            new_description (str): New description text
            
        Returns:
            bool: True if successful
        """
        part = self._find_part_by_line(line_number)
        if not part:
            raise ValueError(f"Line number {line_number} not found")
        
        part['description'] = new_description
        return True
    
    
    def get_classified_parts(self) -> List[Dict[str, Any]]:
        """
        Get the current classified parts structure.
        
        Returns:
            List[Dict]: Copy of the current classified parts
        """
        return copy.deepcopy(self.classified_parts)
    
    def get_item_info(self, line_number: int) -> Optional[Dict[str, Any]]:
        """
        Get complete information about an item.
        
        Args:
            line_number (int): Line number of item
            
        Returns:
            Optional[Dict]: Copy of the item information or None if not found
        """
        part = self._find_part_by_line(line_number)
        return copy.deepcopy(part) if part else None
    
    def list_all_items(self) -> List[Dict[str, Any]]:
        """
        Get a summary list of all items with basic information.
        
        Returns:
            List[Dict]: List of item summaries with line numbers
        """
        summaries = []
        for part in self.classified_parts:
            summary = {
                'line_number': part['line_number'],
                'type': part['type'],
                'indent': part['indent'],
                'item_id': part.get('id'),
                'description': part['description'][:50] + ('...' if len(part['description']) > 50 else ''),
                'has_children': len(part['children']) > 0,
                'parent_line': part.get('parent')
            }
            summaries.append(summary)
        return summaries
    
    # Line number-based methods (primary interface)
    
    def add_item_before_line(self, target_line: int, item_type: str, description: str, 
                            item_id: Optional[int] = None) -> Dict[str, Any]:
        """
        Add a new item before the specified target line.
        This is an alias for add_item_before() for backward compatibility.
        """
        return self.add_item_before(target_line, item_type, description, item_id)
    
    def add_item_after_line(self, target_line: int, item_type: str, description: str, 
                           item_id: Optional[int] = None) -> Dict[str, Any]:
        """
        Add a new item after the specified target line.
        This is an alias for add_item_after() for backward compatibility.
        """
        return self.add_item_after(target_line, item_type, description, item_id)
    
    def add_item_under_line(self, target_line: int, item_type: str, description: str, 
                           item_id: Optional[int] = None) -> Dict[str, Any]:
        """
        Add a new item under the specified target line.
        This is an alias for add_item_under() for backward compatibility.
        """
        return self.add_item_under(target_line, item_type, description, item_id)

